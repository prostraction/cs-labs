/*

1. Что это за программа:  
    Это решатель уравнения теплопроводности в 2D области методом конечных разностей. Она моделирует:
    - Распределение температуры в прямоугольной области
    - Граничные условия: фиксированная температура на вертикальных границах
    - Начальные условия: нулевая температура внутри области
    - Процесс установления стационарного распределения
        
2. Как использовать:
    - Скомпилируйте: `g++ -std=c++11 -o heat_solver heat_solver.cpp`
    - Запустите: `./heat_solver`
    - Результаты будут в файлах:
        - `Rez02.txt` - финальное распределение температуры
        - `Dat02.txt` - временные ряды с датчиков
            
Программа решает уравнение ∂T/∂t = α(∂²T/∂x² + ∂²T/∂y²) с α=1, используя явную схему Эйлера.
*/

#include <iostream>
#include <fstream>
#include <vector>
#include <cmath>
#include <algorithm>

// Структура для хранения координат датчиков температуры
struct Sensor {
    int i;  // координата i (по горизонтали)
    int j;  // координата j (по вертикали)
};

int main() {
    // Параметры моделирования
    const double a = 1.0;        // реальный горизонтальный размер области
    const double b = 1.0;        // реальный вертикальный размер области
    const double L = b / a;      // коэффициент масштабирования
    const double Eps = 0.00001;  // точность выполнения условия стационарности
    const int N = 21;            // количество узлов по горизонтали
    const int M = 21;            // количество узлов по вертикали
    const int K = N;             // максимальное количество датчиков температуры
    
    const double dx = 1.0 / (N - 1);  // шаг по горизонтали
    const double dy = L / (M - 1);    // шаг по вертикали
    
    // Лямбда-функция для вычисления новой температуры (C++11 feature)
    auto calculateNewTemperature = [dx, dy](const std::vector<std::vector<double>>& T, 
                                           int i, int j, double dt) -> double {
        double Tij = T[i][j];
        // Явная схема для уравнения теплопроводности
        double TT = Tij + dt * ((T[i+1][j] - 2*Tij + T[i-1][j]) / (dx*dx) +
                                (T[i][j+1] - 2*Tij + T[i][j-1]) / (dy*dy));
        return TT;
    };
    
    // Инициализация переменных
    double time = 0.0;      // текущее время
    int step = 0;           // количество шагов
    double Err = Eps + 1.0; // ошибка (инициализируем больше Eps)
    
    // Определение шага по времени для устойчивости схемы
    double dt = 0.9 * std::min(dx*dx, dy*dy) / 2.0;
    
    // Инициализация поля температур
    std::vector<std::vector<double>> T(N, std::vector<double>(M, 0.0));
    
    // Установка граничных условий
    for (int j = 0; j < M; j++) {
        T[0][j] = 1.0;    // левая граница
        T[N-1][j] = 1.0;  // правая граница
    }
    
    // Инициализация датчиков температуры
    int sensorCount = N / 2;  // количество датчиков
    std::vector<Sensor> sensors(sensorCount);
    for (int i = 0; i < sensorCount; i++) {
        sensors[i] = {i, M / 2};  // размещаем по центру по вертикали
    }
    
    // Открытие файлов для записи результатов
    std::ofstream f("Rez02.txt");  // файл для стационарного решения
    std::ofstream g("Dat02.txt");  // файл для показаний датчиков
    
    // Основной цикл моделирования
    while (Err >= Eps) {
        Err = 0.0;
        
        // Обновление поля температур
        for (int i = 1; i < N - 1; i++) {
            for (int j = 1; j < M - 1; j++) {
                double T1 = calculateNewTemperature(T, i, j, dt);
                Err += std::abs(T1 - T[i][j]) / dt;  // накопление ошибки
                T[i][j] = T1;
            }
        }
        
        // Обновление параметров счета
        time += dt;
        step += 1;
        
        // Вывод параметров счета на экран
        if (step % 10 == 0) {
            std::cout << "Time: " << time << " Error: " << Err << " Step: " << step << std::endl;
        }
        
        // Запись показаний датчиков
        if (step % 1 == 0) {
            g << time << " ";
            for (const auto& sensor : sensors) {
                g << T[sensor.i][sensor.j] << " ";
            }
            g << std::endl;
        }
    }
    
    // Запись финальных результатов
    f << "time = " << time << std::endl;
    f << "Err = " << Err << std::endl;
    f << "Step = " << step << std::endl;
    
    // Запись стационарного распределения температуры
    for (int j = M - 1; j >= 0; j--) {
        for (int i = 0; i < N; i++) {
            f << T[i][j] << " ";
        }
        f << std::endl;
    }
    
    // Закрытие файлов
    f.close();
    g.close();
    
    std::cout << "Расчет завершен. Результаты сохранены в файлы Rez02.txt и Dat02.txt" << std::endl;
    
    return 0;
}